(load-file "errors.lisp")
(load-file "cons.lisp")

(in-package 'lisp2)

(use-package 'errors)
(export 'type-error)
(export 'unknown-method-error)

(use-package 'cons)
(export 'nil)
(export 'nil?)
(export 'cons)
(export 'car)
(export 'set-car!)
(export 'cdr)
(export 'set-cdr!)
(export 'pair?)
(export 'list)
(export 'list?)
(export 'cdr)
(export 'cdar)
(export 'cadr)
(export 'caar)
(export 'cddr)
(export 'caaar)
(export 'caadr)
(export 'cadar)
(export 'caddr)
(export 'cdaar)
(export 'cdadr)
(export 'cddar)
(export 'cdddr)
(export 'caaaar)
(export 'caaadr)
(export 'caadar)
(export 'caaddr)
(export 'cadaar)
(export 'cadadr)
(export 'caddar)
(export 'cadddr)
(export 'cdaaar)
(export 'cdaadr)
(export 'cdadar)
(export 'cdaddr)
(export 'cddaar)
(export 'cddadr)
(export 'cdddar)
(export 'cddddr)

;; dark arts at work
(export 'to-symbol)
(defun to-symbol (s)
  (if (string? s)
    (lisp:car (lisp:load-string (format-string "'({})" s)))
    (type-error "argument is not a string:" s)))

(export 'list2cons)
(defun list2cons (v)
  (if (lisp:list? v)
    (lisp:apply list (lisp:map 'list list2cons v))
    v))

(export 'qlist)
(defmacro qlist (&rest v)
  (if (lisp:nil? v)
    '()
    (let ([qelements (lisp:map 'list lisp2:list2cons v)])
      (quasiquote (lisp:apply cons:list
                              '((unquote-splicing qelements)))))))

;; gross macro to produce a cons list out of a quasiquote.  the argument bust
;; be an unquoted lisp:list
;;    (quasiquote-list (a b c))           ;; like (list2cons '(a b c))
;;    (quasiquote-list (a b (unquote c))) ;; like (list2cons (concat '(a b) (list c)))
(export 'quasiquote-list)
(defmacro quasiquote-list (v)
  (lisp:quasiquote (list2cons (lisp:quasiquote (unquote v)))))

(export 'symbol)
(defmacro symbol (s) (lisp:quasiquote (lisp:car '((unquote s)))))

(export 'list-equal?)
(defun list-equal? (a b)
  (if (equal? (type a) (type b))
    (if (nil? a)
      true
      (if (pair? a)
        (and (list-equal? (car a) (car b))
             (list-equal? (cdr a) (cdr b)))
        (equal? a b)))
    false))

(export 'map)
(defun map (fun lis)
  (cond ((nil? lis) nil)
        ((list? lis)
         (cons (funcall fun (car lis))
               (map fun (cdr lis))))
        (:else (type-error "argument is not a list:" lis))))

(export 'for-each)
(defun for-each (fun lis)
  (cond ((nil? lis))
        ((list? lis)
         (funcall fun (car lis))
         (for-each fun (cdr lis)))
        (:else (type-error "argument is not a list:" lis))))

(export 'select)
(defun select (fun lis)
  (cond ((pair? lis)
         (if (funcall fun (car lis))
           (cons (car lis) (select fun (cdr lis)))
           (select fun (cdr lis))))
        ((nil? lis) lis)
        (:else (type-error "argument is not a list:" lis))))

(export 'reject)
(defun reject (fun lis)
  (select (lambda (x) (not (funcall fun x)))
          lis))

(export 'all?)
(defun all? (predicate lis)
  (cond ((pair? lis)
         (and (funcall predicate (car lis))
              (all? predicate (cdr lis))))
        ((nil? lis)
         true)
        (:else (type-error "argument is not a list:" lis))))

(export 'any?)
(defun any? (predicate lis)
  (cond ((pair? lis)
         (or (funcall predicate (car lis))
             (any? predicate (cdr lis))))
        ((nil? lis)
         false)
        (:else (type-error "argument is not a list:" lis))))

(defun pivot (less p lis l r)
  (cond ((nil? lis)
         (cons l r))
        ((pair? lis)
         (if (funcall less p (car lis))
           (pivot less p (cdr lis) l (cons (car lis) r))
           (pivot less p (cdr lis) (cons (car lis) l) r)))
        (:else (type-error "argument is not a list:" lis))))

(defun qsort (less p lis)
  (let* ([partition (pivot less p lis nil nil)]
         [left (sort less (car partition))]
         [right (sort less (cdr partition))])
    (concat left (cons p right))))

(export 'sort)
(defun sort (less lis)
  (cond ((nil? lis) lis)
        ((pair? lis) (qsort less (car lis) (cdr lis)))
        (:else (type-error "argument is not a list:" lis))))

(defun dedupe (eq a b lis)
  (if (funcall eq a b)
    (if (pair? lis)
      (dedupe eq a (car lis) (cdr lis))
      (if (nil? lis)
        (cons a nil)
        (type-error "argument is nota list:" lis)))
    (cons a (unique eq (cons b lis)))))
        

(export 'unique)
(defun unique (eq lis)
  (cond ((pair? lis)
         (if (pair? (cdr lis))
           (dedupe eq (car lis) (cadr lis) (cddr lis))
           lis))
        ((nil? lis) lis)
        (:else (type-error "argument is not a list:" lis))))

(export 'concat)
(defun concat (lis1 lis2)
  (if (nil? lis1)
    lis2
    (cons (car lis1) (concat (cdr lis1) lis2))))

(export 'append)
(defun append(lis x)
  (if (nil? lis)
    (cons x nil)
    (cons (car lis) (append (cdr lis) x))))

(export 'append-unique)
(defun append-unique(eq lis x)
  (if (nil? lis)
    (cons x nil)
    (if (funcall eq (car lis) x)
      lis
      (cons (car lis) (append-unique eq (cdr) x)))))

(defun format-list-inner (v rest)
  (cond ((nil? rest) (format-string "{}" (format-list v)))
        ((list? rest)
         (format-string "{} {}" (format-list v) (format-list-inner (car rest) (cdr rest))))
        (:else
         (format-string "{} . {}" (format-list v) (format-list rest)))))

(export 'format-list)
(defun format-list (v)
  (cond
    ((nil? v) "()")
    ((list? v) (lisp:concat 'string "(" (format-list-inner (car v) (cdr v)) ")"))
    ((tagged-value? v)
     (lisp:concat 'string "#{" (format-string "{} {}" (type v) (format-list (user-data v))) "}"))
    (:else (format-string "{}" v))))

(export 'debug-list)
(defun debug-list (v)
  (debug-print (format-list v))
  v)

(defun not (v)
  (if (nil? v) true
    (if (lisp:nil? v) false
      (lisp:not v))))

(defun true? (v)
  (if (nil? v) false
    (if (lisp:nil? v) true
      v)))

(defun cons2list (v)
  (labels ([inner (lis v)
              (if (nil? v)
                lis
                (let* ([head (car v)]
                       [tail (cdr v)])
                  (inner (lisp:append 'list lis head) tail)))])
    (inner '() v)))

(export 'apply)
(defun apply (fn &rest args)
  (if (lisp:nil? args)
    (error 'argument-error "not enough arguments")
    (let* ([n (- (lisp:length args) 1)]
           [fixed (slice 'list args 0 n)]
           [seq (lisp:nth args n)])
      (cond ((nil? seq) (lisp:apply fn fixed))
            ((list? seq) (lisp:apply fn (lisp:concat 'list fixed (cons2list seq))))
            (:else (type-error "last argument is not a list:" seq))))))

(export 'call-method)
(defmacro call-method (recv method &rest args)
  (let ([r (gensym)]
        [m (gensym)])
    (quasiquote (lisp:let* ([(unquote r) (lisp:user-data (unquote recv))]
                            [(unquote m) (lisp:if (lisp:sorted-map? (unquote r))
                                                  (lisp:get (unquote r) (unquote method))
                                                  (lisp:funcall (unquote r) (unquote method)))])
                           (lisp:funcall (unquote m) (unquote-splicing args))))))

(deftype maphack (&rest args) (lisp:apply lisp:sorted-map args))

(export 'sorted-map)
(defun sorted-map (&rest args)
  (lisp:apply new maphack args))

(export 'keys)
(defun keys (m)
  (lisp:apply list (lisp:keys m)))

(export 'key?)
(defun key? (m k)
  (lisp:key? (user-data m) k))

(export 'get)
(defun get (m k)
  (if (lisp:key? m k)
    (lisp:get (user-data m) k)
    nil))

(export 'assoc!)
(defun assoc! (m k)
  (lisp:assoc! (user-data m) k))

(export 'foldr)
(defun foldr (fun acc lis)
  (cond ((nil? lis) acc)
        ((pair? lis) (fun (car lis) (foldr fun acc (cdr lis)))
        (:else (type-error "argument is not a list:" lis)))))

(export 'foldl)
(defun foldl (fun acc lis)
  (cond ((nil? lis) acc)
        ((pair? lis) (foldl fun (fun acc (car lis)) (cdr lis)))
        (:else (type-error "argument is not a list:" lis))))

(export 'flip)
(defun flip (fun)
  (lambda (x y) (funcall fun y x)))

(export 'reverse)
(defun reverse (lis)
  (foldl (flip cons) nil lis))

(assert (equal? "(1 2 3)" (format-list (list 1 2 3))))
(assert (equal? "(1 2)" (format-list (list 1 2))))
(assert (equal? "(1 . 2)" (format-list (cons 1 2))))
(assert (equal? "(1 2 . 3)" (format-list (cons 1 (cons 2 3)))))
(assert (equal? "(1 2)" (format-list (list 1 2))))
(let* ([v (list 1 2 3)])
  (set-car! v 'a)
  (assert (equal? "('a 2 3)" (format-list v))))
(let* ([v (list 1 2 3)])
  (set-car! (cdr v) 'a)
  (assert (equal? "(1 'a 3)" (format-list v))))
(let* ([v (list 1 2 3)])
  (set-car! (cddr v) 'a)
  (assert (equal? "(1 2 'a)" (format-list v))))
(let* ([v (list 1 2 3)])
  (set-cdr! v 'a)
  (assert (equal? "(1 . 'a)" (format-list v))))
(let* ([v (list 1 2 3)])
  (set-cdr! (cdr v) 'a)
  (assert (equal? "(1 2 . 'a)" (format-list v))))
(let* ([v (list 1 2 3)])
  (set-cdr! (cddr v) 'a)
  (assert (equal? "(1 2 3 . 'a)" (format-list v))))
(assert (equal? "(1 2 3 4 5 6)" (format-list (concat (list 1 2 3) (list 4 5 6)))))

(assert (list-equal? (list 1 2 3 4) (list 1 2 3 4)))
(assert (list-equal? (list 1 2 3 4) (sort < (list 1 2 3 4))))
(assert (list-equal? (list 1 2 3 4) (sort < (list 3 2 1 4))))
(assert (list-equal? (list 1 2 3 4) (unique equal? (list 1 2 3 4))))
(assert (list-equal? (list 1 2 3 4) (unique equal? (list 1 1 2 3 4))))
(assert (list-equal? (list 1 2 3 4) (debug-list (unique equal? (list 1 2 2 2 3 4 4)))))
(assert (list-equal? (list 1 2 3 2 4) (debug-list (unique equal? (list 1 2 3 2 4)))))
(assert (list-equal? (list 1 2 3 4) (debug-list (unique equal? (sort < (list 1 2 3 2 4))))))
(assert (list-equal? (list 1 2 3 4) (debug-list (select (lambda (x) (> 5 x)) (list 10 1 2 7 8 3 4)))))
(assert (list-equal? (list 1 2 3 4) (debug-list (reject (lambda (x) (< 5 x)) (list 10 1 2 7 8 3 4)))))
(debug-print (format-list (cons 1 (cons 2 3))))
(debug-print (cons2list (cons 1 (cons 2 (cons 3 nil)))))
(assert (= 6 (apply + (list 1 2 3))))
