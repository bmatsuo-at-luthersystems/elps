(in-package 'cons)
(use-package 'errors)

(deftype _nil ())

(export 'nil)
(set 'nil (new _nil))

(export 'nil?)
(defun nil? (v) (type? _nil v))

(deftype mycons (head tail)
  (labels ([car () head]
           [cdr () tail]
           [set-car! (x) (set! head x)]
           [set-cdr! (x) (set! tail x)])
    (let* ([m (sorted-map 'car car
                          'cdr cdr
                          'set-car! set-car!
                          'set-cdr! set-cdr!)])
      (lambda (name &rest args)
        (let* ([method (get m name)])
          (if (lisp:nil? method)
            (error 'unrecognized-method (to-string name))
            (lisp:apply method args)))))))

(export 'cons)
(defun cons (head tail) (new mycons head tail))

(export 'car)
(defun car (v)
  (cond 
    ((nil? v) nil)
    ((list? v) (funcall (user-data v) 'car))
    (:else (type-error "argument is not a list" v))))

(export 'set-car!)
(defun set-car! (v x)
  (cond 
    ((nil? v) nil)
    ((list? v) (funcall (user-data v) 'set-car! x))
    (:else (type-error "argument is not a list" v))))

(export 'cdr)
(defun cdr (v)
  (cond 
    ((nil? v) nil)
    ((list? v) (funcall (user-data v) 'cdr))
    (:else (type-error "argument is not a list" v))))

(export 'set-cdr!)
(defun set-cdr! (v x)
  (cond 
    ((nil? v) nil)
    ((list? v) (funcall (user-data v) 'set-cdr! x))
    (:else (type-error "argument is not a list" v))))

(export 'pair?)
(defun pair? (v) (type? mycons v))

(export 'list?)
(defun list? (v) (or (nil? v) (pair? v)))

(export 'list)
(defun list (&rest v) (foldr cons nil v))

(export 'cdar)
(defun cdar (v) (cdr (car v)))
(export 'cadr)
(defun cadr (v) (car (cdr v)))
(export 'caar)
(defun caar (v) (car (car v)))
(export 'cddr)
(defun cddr (v) (cdr (cdr v)))
(export 'caaar)
(defun caaar (v) (car (car (car v))))
(export 'caadr)
(defun caadr (v) (car (car (cdr v))))
(export 'cadar)
(defun cadar (v) (car (cdr (car v))))
(export 'caddr)
(defun caddr (v) (car (cdr (cdr v))))
(export 'cdaar)
(defun cdaar (v) (cdr (car (car v))))
(export 'cdadr)
(defun cdadr (v) (cdr (car (cdr v))))
(export 'cddar)
(defun cddar (v) (cdr (cdr (car v))))
(export 'cdddr)
(defun cdddr (v) (cdr (cdr (cdr v))))
(export 'caaaar)
(defun caaaar (v) (car (car (car (car v)))))
(export 'caaadr)
(defun caaadr (v) (car (car (car (cdr v)))))
(export 'caadar)
(defun caadar (v) (car (car (cdr (car v)))))
(export 'caaddr)
(defun caaddr (v) (car (car (cdr (cdr v)))))
(export 'cadaar)
(defun cadaar (v) (car (cdr (car (car v)))))
(export 'cadadr)
(defun cadadr (v) (car (cdr (car (cdr v)))))
(export 'caddar)
(defun caddar (v) (car (cdr (cdr (car v)))))
(export 'cadddr)
(defun cadddr (v) (car (cdr (cdr (cdr v)))))
(export 'cdaaar)
(defun cdaaar (v) (cdr (car (car (car v)))))
(export 'cdaadr)
(defun cdaadr (v) (cdr (car (car (cdr v)))))
(export 'cdadar)
(defun cdadar (v) (cdr (car (cdr (car v)))))
(export 'cdaddr)
(defun cdaddr (v) (cdr (car (cdr (cdr v)))))
(export 'cddaar)
(defun cddaar (v) (cdr (cdr (car (car v)))))
(export 'cddadr)
(defun cddadr (v) (cdr (cdr (car (cdr v)))))
(export 'cdddar)
(defun cdddar (v) (cdr (cdr (cdr (car v)))))
(export 'cddddr)
(defun cddddr (v) (cdr (cdr (cdr (cdr v)))))

(assert (nil? nil))
(assert (not (nil? (cons 1 nil))))
(assert (not (nil? (list 1))))
(assert (equal? nil (car nil)))
(assert (equal? nil (cdr nil)))
(assert (equal? nil (list)))
(assert (equal? 1 (car (list 1))))
(assert (equal? nil (cdr (list 1))))
(assert (equal? nil (cdr (list 1))))
(assert (not (nil? (cdr (list 1 2)))))
(assert (not (nil? (car (cdr (list 1 2))))))
(assert (equal? 2 (car (cdr (cons 1 (cons 2 nil))))))
(assert (equal? 2 (car (cdr (list 1 2 )))))
(assert (equal? 3 (caddr (list 1 2 3))))
